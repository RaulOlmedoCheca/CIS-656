package client;import server.PresenceService;import server.RegistrationInfo;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.Socket;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.Scanner;import java.util.Vector;public class ChatClient {    private static final String COMMAND_FRIENDS = "friends";    private static final String COMMAND_TALK = "talk";    private static final String COMMAND_BROADCAST = "broadcast";    private static final String COMMAND_BUSY = "busy";    private static final String COMMAND_AVAILABLE = "available";    private static final String COMMAND_EXIT = "exit";    private static PresenceService server;    private static RegistrationInfo currentUserInfo;    public static void main(String args[]) throws NotBoundException {        boolean isExiting = false;        if (areArgumentsCorrect(args)){            if (System.getSecurityManager() == null) {                System.setSecurityManager(new SecurityManager());            }            try {                String name = "PresenceServiceImpl";                Registry registry = LocateRegistry.getRegistry(args[1], Integer.parseInt(args[2]));                server = (PresenceService) registry.lookup(name);                currentUserInfo = new RegistrationInfo(args[0], args[1], Integer.parseInt(args[2]), true);                if (server.lookup(currentUserInfo.getUserName()) != null) {                    System.out.println("The username is already in use");                    System.out.println("Exiting...");                    return;                } else {                    server.register(currentUserInfo);                }            } catch (RemoteException e) {                System.err.println("ChatClient exception:");                e.printStackTrace();            }            MessageListener currentUserMessageListener = new MessageListener(currentUserInfo, server);            Thread messageListenerThread = new Thread(currentUserMessageListener);            messageListenerThread.start();            while (!isExiting) {                System.out.println(" >> ");                Scanner sc = new Scanner(System.in);                String input = sc.nextLine();                isExiting = commandInterpreter(input);            }            System.exit(0);        } else {            System.out.println("Incorrect arguments, exiting...");        }    }    private static boolean areArgumentsCorrect(String[]  args){        if (args[0].equals("${user}")){            System.out.println("A username is required");            return false;        } else if (args[1].equals("localhost") && args[2].equals("1099")){            System.out.println("Using default host and port");            return true;        } else if (args[1].equals("localhost")) {            System.out.println("Using default host");            return true;        } else if (args[2].equals("1099")){            System.out.println("Using default port");            return true;        }        return true;    }    private static boolean commandInterpreter(String completeCommand) {        boolean isExiting = false;        String[] splitCommand = completeCommand.split(" ");        switch (splitCommand[0]) {            case COMMAND_FRIENDS:                if (splitCommand.length != 1) {                    System.err.println("Wrong usage of friends");                } else {                    executeFriends();                }                break;            case COMMAND_TALK:                if (splitCommand.length != 3) {                    System.err.println("Wrong usage of talk");                } else {                    executeTalk(splitCommand[1], splitCommand[2]);                }                break;            case COMMAND_BROADCAST:                if (splitCommand.length != 2) {                    System.err.println("Wrong usage of broadcast");                } else {                    executeBroadcast(splitCommand[1]);                }                break;            case COMMAND_BUSY:                if (splitCommand.length != 1) {                    System.err.println("Wrong usage of busy");                } else {                    changeStatus(currentUserInfo, false);                }                break;            case COMMAND_AVAILABLE:                if (splitCommand.length != 1) {                    System.err.println("Wrong usage of available");                } else {                    changeStatus(currentUserInfo, true);                }                break;            case COMMAND_EXIT:                if (splitCommand.length != 1) {                    System.err.println("Wrong usage of available");                } else {                    executeExit();                    isExiting = true;                }                break;            default:                System.err.println("Invalid command");        }        return isExiting;    }    private static void executeTalk(String username, String message) {        try {            RegistrationInfo targetInfo = server.lookup(username);            if (targetInfo == null) {                System.out.println("The user " + username + " does not exist in the server");            } else if (!targetInfo.getStatus()) {                System.out.println("The user is not available at this moment");            } else if (targetInfo.getUserName().equals(currentUserInfo.getUserName())) {                System.out.println("You shouldn't be talking to yourself");            } else {                try {                    Socket sendSocket = new Socket(targetInfo.getHost(), targetInfo.getPort());                    //System.out.println("Sending message to " + targetInfo.getPort());                    OutputStreamWriter writer = new OutputStreamWriter(sendSocket.getOutputStream());                    writer.write(username + ": " + message);                    writer.flush();                    sendSocket.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        } catch (RemoteException e) {            e.printStackTrace();        }    }    private static void executeBroadcast(String message) {        Vector<RegistrationInfo> registeredUsers;        try {            registeredUsers = server.listRegisteredUsers();            for (RegistrationInfo userInfo : registeredUsers) {                if (userInfo.getStatus() && !userInfo.getUserName().equals(currentUserInfo.getUserName())) {                    executeTalk(userInfo.getUserName(), message);                }            }        } catch (RemoteException e) {            e.printStackTrace();        }    }    private static void executeFriends() {        try {            Vector<RegistrationInfo> users = server.listRegisteredUsers();            System.out.println("Users:");            for (RegistrationInfo userInfo : users) {                System.out.println(userInfo.getUserName() + " (" + (userInfo.getStatus() ? "connected" : "busy") + ")");            }        } catch (RemoteException e) {            e.printStackTrace();        }    }    private static void changeStatus(RegistrationInfo userCurrentInfo, boolean newStatus) {        if (userCurrentInfo.getStatus() == newStatus) {            System.out.println("You already have that status");        } else {            try {                server.updateRegistrationInfo(new RegistrationInfo(                        userCurrentInfo.getUserName(),                        userCurrentInfo.getHost(),                        userCurrentInfo.getPort(),                        newStatus));                userCurrentInfo.setStatus(newStatus);                System.out.println("Status changed to " + (newStatus ? "available" : "busy"));            } catch (RemoteException e) {                e.printStackTrace();            }        }    }    private static void executeExit() {        try {            System.out.println("Goodbye!");            server.unregister(currentUserInfo.getUserName());        } catch (RemoteException e) {            e.printStackTrace();        }    }}